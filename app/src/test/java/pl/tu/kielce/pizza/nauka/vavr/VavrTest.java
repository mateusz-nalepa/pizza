package pl.tu.kielce.pizza.nauka.vavr;

import io.vavr.Lazy;
import io.vavr.Tuple;
import io.vavr.Tuple2;
import io.vavr.collection.List;
import io.vavr.collection.Set;
import io.vavr.collection.Stream;
import io.vavr.control.Option;
import io.vavr.control.Try;
import org.junit.Test;
import org.junit.runner.RunWith;
import org.mockito.runners.MockitoJUnitRunner;

import java.net.URI;
import java.net.URISyntaxException;
import java.util.function.Supplier;

import static io.vavr.API.$;
import static io.vavr.API.Case;
import static io.vavr.API.LinkedSet;
import static io.vavr.API.Match;
import static io.vavr.API.unchecked;
import static io.vavr.Predicates.instanceOf;
import static java.util.stream.Collectors.toList;

@RunWith(MockitoJUnitRunner.class)
public class VavrTest
{
    @Test
    public void creatingCollections()
    {
//        Function1, Function2...Function8, it's generated by scala
//        Tuple4, TupleN
        
        List<Integer> of = List.of(1, 2, 3, 4, 5);
        Set<Integer> integers = LinkedSet(1, 2, 3, 4, 5);
    }
    
    @Test
    public void option()
    {
        //option to taki ulepszony Optional, jest m.in. serializowalny!
        Option<String> of = Option.of("42");
        
        java.util.List<Integer> collect = List
            .of(Option.of(42), Option.of(72))
            .filter(Option::isDefined)
            .map(Option::get)
            .collect(toList());

//        równoznaczne to
        List<Integer> integers = List
            .of(Option.of(42), Option.of(72))
            .flatMap(o -> o); //identity function
    }
    
    @Test
    public void testTry()
    {
        String orElseGet = Try
            .of(() -> new URI(""))
            .recoverWith(URISyntaxException.class, Try.of(() -> new URI("")))
            .map(URI::toString)
            .andThen(String::toUpperCase)
            .getOrElseGet(throwable -> "5");
    }
    
    @Test
    public void testSupplierFromJava()
    {
        Supplier<Integer> supplier = VavrTest::asd;
        
        //wyświetli 3x przetwarzanie!!
        supplier.get();
        supplier.get();
        supplier.get();
    }
    
    @Test
    public void testLazyFromVavr()
    {
        Lazy<Integer> lazy = Lazy.of(VavrTest::asd);
        
        //wyświetli tylko 1x przetwarzanie!!
        lazy.get();
        lazy.get();
        lazy.get();
    }
    
    private static Integer asd()
    {
        System.out.println("Przetwarzanie....");
        return 56;
    }
    
    @Test
    public void testListFromVavr()
    {
        List<Integer> l = List.of(1, 2, 3, 4, 5);
        
        l.drop(1);
        l.tail();
        
        //zawsze zwracają nową instancję!
    }
    
    @Test
    public void testCollectionsFromVavr()
    {
        List<Integer> l = List.of(1, 2, 3, 4, 5);
        
        List<Integer> integers = l.zipWithIndex((x, y) -> x + y);
        
        System.out.println(l.zipWithIndex());
        
        System.out.println(l);
        System.out.println(integers);
        //zawsze zwracają nową instancję!
    }
    
    @Test
    public void testVavrListCollect()
    {
        java.util.List<Integer> collect = List
            .of(1, 2, 3, 4, 5)
            .collect(toList());
    }
    
    @Test
    public void streamIterate()
    {
        Stream<Integer> iterate = Stream.iterate(0, i -> i++);
        
        System.out.println(iterate);
    }
    
    @Test
    public void testVavrListToJavaList()
    {
        //constant time converting!
        java.util.List<Integer> integers = List
            .of(1, 2, 3, 4, 5)
            .asJava();
    }
    
    @Test
    public void tuples()
    {
        Tuple2<String, Integer> tuple = Tuple.of("Java", 8);
        
        String apply = tuple.apply((s, i) -> s + i);
        
        System.out.println(apply);
        
        //equal
        String java = Tuple.of("Java", 8).apply((s, i) -> s + i);
        System.out.println(java);
    }
    
    @Test
    public void exceptions()
    {
        List
            .of("")
            .map(unchecked(s -> new URI(s))); //throws exception silently
    }
    
    @Test
    public void matchCase()
    {
        Object a = "42";
        
        Match(a)
            .of(
                Case($(instanceOf(String.class)), "str"),
                Case($(instanceOf(Integer.class)), "int")
               );
    }
}

